from sympy import *
import math

def bisection_calc(f,f_d,start_point ,end_point,epsilon,i,n):
    a_n = start_point
    b_n = end_point
    k=0
    if i==0:
        while (abs(a_n-b_n)>epsilon):
            m_n = (a_n + b_n)/2  # the middle
            f_m_n = f(m_n)
            if f(a_n)*f_m_n < 0:
                a_n = a_n
                b_n = m_n
            elif f(b_n)*f_m_n < 0:
                a_n = m_n
                b_n = b_n
            elif f_m_n == 0:
                print("Found exact solution.")
                return m_n
            elif k >= n:
                print(k, " Is the max iteration according to error calculation\n")
                print("Bisection method fails,please select another methode ")
                return None
            k=k+1
        print(k,"iteration")
        print((a_n + b_n)/2)
    else:
        while (abs(a_n-b_n)>epsilon):
            m_n = (a_n + b_n)/2  # the middle
            f_m_n = f_d(m_n)
            if f_d(a_n)*f_m_n < 0:
                a_n = a_n
                b_n = m_n
            elif f_d(b_n)*f_m_n < 0:
                a_n = m_n
                b_n = b_n
            elif f_m_n == 0:
                print("Found exact solution.")
                return m_n
            elif k>=n:
                print(k," Is the max iteration according to error calculation\n")
                print("Bisection method fails,please select another methode ")
                return None
            k=k+1
        if abs(f(a_n+b_n))<=epsilon:
            print(k,"iteration")
            print((a_n + b_n) / 2)


def range_check(f,f_d,start_point,end_point,epsilon,i,n):
    a=start_point
    if i==0:
        while (a<end_point):
            if ((f(a)>=0 and f(a+0.1)<=0 )or((f(a)<=0 and f(a+0.1)>=0 ))):
                bisection_calc(f,f_d,a,a+0.1,epsilon,0,n)
                a=a+0.1
            else:
                a=a+0.1
        return
    else:
        while (a<end_point):
            if ((f_d(a)>=0 and f_d(a+0.1)<=0 )or((f_d(a)<=0 and f_d(a+0.1)>=0 ))):
                bisection_calc(f,f_d,a,a+0.1,epsilon,1,n)
                a=a+0.1
            else:
                a=a+0.1
    return


def bisection(f,start_point,end_point,epsilon):
    a=end_point-start_point
    n = -((math.log(10**-10/a))/math.log(2))
    n=int(n+1)
    f_d = f.diff(x) #Derivative
    f_d = lambdify(x, f_d) #create the polinom to function
    f = lambdify(x, f)
    range_check(f,f_d,start_point,end_point,epsilon,1,n)
    range_check(f,f_d,start_point,end_point,epsilon,0,n)


epsilon=0.0001
x = Symbol('x')
f = x**4 + x**3-3*x**2
bisection(f,-3,2,epsilon)

def Secant_Method(f, start_point, end_point, e):
    """
    :param f: polinom function
    :param start_point: start point section
    :param end_point: end point section
    :param e: epsilon- the precision
    :return: dictionary contains the root and number of iteration
    """
    iterations = 0
    xr_minus1 = start_point
    xr = end_point
    xr_plus1 = (xr_minus1*f(xr)-xr*f(xr_minus1))/(f(xr)-f(xr_minus1))
    while xr - xr_plus1 < e and f(xr) != 0:
        iterations += 1
        xr_minus1 = xr
        xr = xr_plus1
        xr_plus1 = (xr_minus1*f(xr)-xr*f(xr_minus1))/(f(xr)-f(xr_minus1))

    return {xr_plus1: iterations}


def CalcRoots():
    """
 
    The function lets to select the method by which we calculate the roots.
    If the function has no roots, you will be notified
    """
    roots = {}
    epsilon = 0.0001
    start_point = -5  # start range
    end_point = 6  # end range
    div_num = (abs(start_point)+abs(end_point)) / 0.1  # will represent the number of iterations we will check the sign change - f(x1)*f(x2)<0
    choice = 0
    while choice != '1' and choice != '2' and choice != '3':
        print("Which method would you like to choose in order to find the equation roots?")
        print("1.Bisection method")
        print("2.Newton-Raphson method")
        print("3.Secant method")
        choice = input()

    for i in range(int(div_num)):
        if i == 0:  # first iteration
            x1 = start_point
            x2 = start_point+0.1
        else:
            x1 = x2
            x2 = x1 + 0.1

        if f(x2) == 0:  # holds the issue when there is a sign change before and after the 0
            roots.update({x2: 0})

        if f(x1)*f(x2) < 0:  # if there is a sign change
            if choice == '1':
                if Check_0(f) is not None:
                    roots.update(Check_0(f))  # 0 can be a root, and is a special check
                roots.update(Bisection_Method(f, x1, x2, epsilon))  # roots that are crossover points(function)
                point = Bisection_Method(fprime(f), x1, x2, epsilon)  # roots that are touching points(function-prime)
                c, iterations = list(point.items())[0]
                if f(c) == 0:  # if the root of the function-prime reset the equation, than its a function root
                    roots.update(point)
            if choice == '2':
                if Check_0(f) is not None:
                    roots.update(Check_0(f))  # 0 can be a root, and is a special check
                roots.update(Newton_Raphson(f, x1, x2, epsilon))
            if choice == '3':
                if Check_0(f) is not None:
                    roots.update(Check_0(f))  # 0 can be a root, and is a special check
                roots.update(Secant_Method(f, x1, x2, epsilon))

    if choice=='1' and len(roots)==0:
        print("No roots using the bisection method")
    if choice=='2' and len(roots)==0:
        print("No roots using the Newton Raphson method")
    if choice=='3' and len(roots)==0:
        print("No roots using the Secant Method method")
    # printing all roots , with thier number of iterations
    for root, iterations in roots.items():
        print("The root is:", round(root, 6), "| number of iterations:", iterations)


def f(x):
    """
    :param x: value of x
    :return: value of f(x)
    """
    return x ** 4 + x ** 3 - 3 * (x ** 2)


def Check_0(f):
    """
    :param f: the function
    :return: dictionary contains root 0
    """
    if f(0) == 0:
        return {0: 0}


def fprime(f):
    """
    :param f: function
    :return: prime function of f
    """
    x = sp.symbols('x')
    f = f(x)
    f_prime = f.diff(x)
    f = lambdify(x, f)
    f_prime = lambdify(x, f_prime)
    return f_prime



CalcRoots()
