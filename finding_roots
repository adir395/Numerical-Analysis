from sympy import *

def bisection_calc(f,start_point ,end_point,epsilon):
    a_n = start_point
    b_n = end_point
    k=0
    while (abs(a_n-b_n)>epsilon):
        m_n = (a_n + b_n)/2  # the middle
        f_m_n = f(m_n)
        if f(a_n)*f_m_n < 0:
            a_n = a_n
            b_n = m_n
        elif f(b_n)*f_m_n < 0:
            a_n = m_n
            b_n = b_n
        elif f_m_n == 0:
            print("Found exact solution.")
            return m_n
        else:
            print("Bisection method fails.")
            return None
        k=k+1
    print(k,"iteration")
    return (a_n + b_n)/2

def range_check(f,start_point,end_point,epsilon):
    if f(start_point )*f(end_point ) >= 0:
        a=start_point
        while (a<=end_point):
            if ((f(a)>=0 and f(a+0.1)<=0 )or((f(a)<=0 and f(a+0.1)>=0 ))):
                print(bisection_calc(f,a,a+0.1,epsilon))
                a=a+0.1
            else:
                a=a+0.1
    else:
        print(bisection_calc(f,start_point,end_point,epsilon))
        return

''''
def range_check2(f,start_point,end_point,epsilon):
    a = symbols('a')
    my_f1 = f(a).diff(a)
    b = symbols('b')
    my_f2 = f(b).diff(b)
    
    if f(a).diff(x)*f(end_point ) >= 0:
        a=start_point
        while (a<=end_point):
            if ((f(a)>=0 and f(a+0.1)<=0 )or((f(a)<=0 and f(a+0.1)>=0 ))):
                print(bisection_calc(f,a,a+0.1,epsilon))
                a=a+0.1
            else:
                a=a+0.1
    else:
        print(bisection_calc(f,start_point,end_point,epsilon))
        return
'''

def check_Derivative(f):
    f_prime = f.diff(x)
    print(f_prime)
    return f_prime

def bisection(f,start_point,end_point,epsilon):
    f_d = check_Derivative(f)
    f_d = lambdify(x, f_d)
    range_check(f_d,start_point,end_point,epsilon)
    f = lambdify(x, f)
    range_check(f,start_point,end_point,epsilon)


epsilon=0.0001
x = Symbol('x')
f = x**4 + x**3-3*x**2
bisection(f,-3,2,epsilon)

